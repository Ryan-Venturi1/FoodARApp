<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Real-time Nutrition Scanner</title>
    <!-- Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.147.0/three.min.js"></script>
    <!-- QuaggaJS to detect barcodes -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/quagga/0.12.1/quagga.min.js"></script>
    <!-- TensorFlow.js for image recognition -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/3.18.0/tf.min.js"></script>
    <!-- Add MobileNet for image classification -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0/dist/mobilenet.min.js"></script>

    <style>
      body, html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        font-family: 'Arial', sans-serif;
        background-color: #000;
      }
      #status {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        background: rgba(0,0,0,0.7);
        color: #fff;
        font-size: 1em;
        text-align: center;
        z-index: 100;
        padding: 0.8em;
        font-weight: 500;
      }
      #videoElement {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: 1;
      }
      #canvas3d {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 2;
        pointer-events: none;
      }
      #recognitionCanvas {
        display: none;
      }
      #quaggaContainer {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 5;
      }
      .button-container {
        position: absolute;
        bottom: 20px;
        width: 100%;
        display: flex;
        justify-content: center;
        z-index: 20;
        gap: 20px;
      }
      .control-button {
        background: rgba(255,255,255,0.9);
        color: #000;
        border: none;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        font-size: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        transition: transform 0.2s ease;
      }
      .control-button:active {
        transform: scale(0.95);
      }
      #scanMode {
        position: absolute;
        top: 60px;
        width: 100%;
        text-align: center;
        z-index: 11;
      }
      .modeBtn {
        background: rgba(255,255,255,0.9);
        border: none;
        border-radius: 20px;
        padding: 10px 20px;
        margin: 0 5px;
        font-size: 14px;
        font-weight: bold;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        transition: all 0.3s ease;
        cursor: pointer;
      }
      .modeBtn:active {
        transform: scale(0.95);
      }
      .active {
        background: #4285f4;
        color: white;
      }
      
      /* Scanner animation */
      .scanner-ui {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none;
      }
      .scan-area {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 280px;
        height: 180px;
        border: 2px solid rgba(66, 133, 244, 0.8);
        border-radius: 10px;
        box-shadow: 0 0 0 5000px rgba(0, 0, 0, 0.5);
      }
      .scan-line {
        position: absolute;
        top: 0;
        left: 0;
        height: 2px;
        width: 100%;
        background: linear-gradient(90deg, transparent, #4285f4, transparent);
        animation: scan 2s linear infinite;
      }
      @keyframes scan {
        0% { top: 0; }
        50% { top: 100%; }
        100% { top: 0; }
      }
      .scan-corners {
        position: absolute;
        width: 100%;
        height: 100%;
      }
      .corner {
        position: absolute;
        width: 20px;
        height: 20px;
        border-color: #4285f4;
        border-style: solid;
        border-width: 0;
      }
      .corner-tl {
        top: -2px;
        left: -2px;
        border-top-width: 4px;
        border-left-width: 4px;
        border-top-left-radius: 8px;
      }
      .corner-tr {
        top: -2px;
        right: -2px;
        border-top-width: 4px;
        border-right-width: 4px;
        border-top-right-radius: 8px;
      }
      .corner-bl {
        bottom: -2px;
        left: -2px;
        border-bottom-width: 4px;
        border-left-width: 4px;
        border-bottom-left-radius: 8px;
      }
      .corner-br {
        bottom: -2px;
        right: -2px;
        border-bottom-width: 4px;
        border-right-width: 4px;
        border-bottom-right-radius: 8px;
      }
      
      /* Loading indicator */
      .loading-indicator {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 50;
      }
      .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: #4285f4;
        animation: spin 1s ease-in-out infinite;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      
      /* Item detection highlight */
      .detection-box {
        position: absolute;
        border: 3px solid #4CAF50;
        border-radius: 8px;
        z-index: 15;
        pointer-events: none;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        transition: all 0.3s ease-out;
        display: none;
      }
      
      /* Permission error overlay */
      #permissionError {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 1000;
        color: white;
        text-align: center;
        padding-top: 30%;
      }
      #permissionError h2 {
        margin-bottom: 20px;
      }
      #permissionError button {
        background: #4285f4;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 24px;
        font-weight: bold;
        margin-top: 20px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="status">Initializing scanner...</div>
    <div id="scanMode">
      <button id="barcodeMode" class="modeBtn active">Barcode</button>
      <button id="imageMode" class="modeBtn">Package Recognition</button>
    </div>
    
    <!-- Video element for TensorFlow mode -->
    <video id="videoElement" autoplay playsinline></video>
    
    <!-- Canvas for image recognition -->
    <canvas id="recognitionCanvas"></canvas>
    
    <!-- Three.js canvas -->
    <canvas id="canvas3d"></canvas>
    
    <!-- Container for QuaggaJS -->
    <div id="quaggaContainer"></div>
    
    <!-- Scanner UI elements -->
    <div class="scanner-ui" id="barcodeScannerUI">
      <div class="scan-area">
        <div class="scan-line"></div>
        <div class="scan-corners">
          <div class="corner corner-tl"></div>
          <div class="corner corner-tr"></div>
          <div class="corner corner-bl"></div>
          <div class="corner corner-br"></div>
        </div>
      </div>
    </div>
    
    <!-- Detection box for package recognition -->
    <div class="detection-box" id="detectionBox"></div>
    
    <!-- Loading indicator -->
    <div class="loading-indicator" id="loadingIndicator">
      <div class="spinner"></div>
    </div>
    
    <!-- Camera permission error overlay -->
    <div id="permissionError">
      <h2>Camera Access Required</h2>
      <p>Please allow camera access to use this scanner.</p>
      <button id="retryPermission">Try Again</button>
    </div>
    
    <div class="button-container">
      <button id="switchCameraBtn" class="control-button">ðŸ”„</button>
    </div>

    <script>
      // Global variables
      let mobilenetModel = null;
      let currentMode = 'barcode'; // Default mode
      const videoElement = document.getElementById('videoElement');
      const canvas = document.getElementById('recognitionCanvas');
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      let isQuaggaRunning = false;
      let frontCamera = false;
      let currentStream = null;
      const quaggaContainer = document.getElementById('quaggaContainer');
      const barcodeScannerUI = document.getElementById('barcodeScannerUI');
      const detectionBox = document.getElementById('detectionBox');
      const loadingIndicator = document.getElementById('loadingIndicator');
      const permissionError = document.getElementById('permissionError');
      
      // Image recognition variables
      let isRecognizing = false;
      let lastRecognitionTime = 0;
      const recognitionInterval = 500; // Milliseconds between recognition attempts
      let recognizedItems = new Map(); // Track consistent recognitions
      let lastDetectedItemBox = null;
      
      // Three.js variables
      let scene, camera, renderer;
      let nutritionPanel;
      let isThreeJsInitialized = false;
      
      // Food database cache for faster lookups
      const foodCache = new Map();
      
      // Extended food keyword list for better recognition
      const foodKeywords = [
        'food', 'snack', 'chip', 'crisp', 'fruit', 'vegetable', 'meat', 'drink', 'beverage',
        'chocolate', 'candy', 'sweet', 'cookie', 'cracker', 'bread', 'cereal', 'yogurt', 
        'milk', 'juice', 'soda', 'water', 'coffee', 'tea', 'sandwich', 'burger', 'pizza',
        'pasta', 'rice', 'bean', 'nut', 'cake', 'pie', 'ice cream', 'dessert', 'soup',
        'salad', 'sauce', 'oil', 'vinegar', 'sugar', 'salt', 'pepper', 'spice', 'herb',
        'package', 'box', 'bag', 'bottle', 'can', 'container', 'wrapper', 'packet',
        'doritos', 'lays', 'cheetos', 'pringles', 'oreo', 'kitkat', 'snickers', 'popcorn',
        'cola', 'pepsi', 'sprite', 'fanta', 'mountain dew', 'redbull', 'monster', 'coke',
        // Add generic terms to improve detection
        'packaged', 'processed', 'junk', 'fast', 'frozen', 'dried', 'instant', 'ready',
        // Common brands
        'nestle', 'kraft', 'hershey', 'nabisco', 'frito', 'kellogg', 'heinz', 'campbell',
        'coca', 'pepsi', 'mars', 'general', 'mills', 'unilever', 'danone', 'mondelez'
      ];
      
      // Initialize Three.js scene with modern design
      function initThreeJs() {
        if (isThreeJsInitialized) return true;
        
        try {
          // Create scene
          scene = new THREE.Scene();
          
          // Create camera (perspective)
          camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          camera.position.z = 5;
          
          // Create renderer
          renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('canvas3d'),
            alpha: true,
            antialias: true // Smoother edges
          });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setClearColor(0x000000, 0); // Transparent background
          renderer.setPixelRatio(window.devicePixelRatio); // Sharper rendering
          
          // Better lighting for 3D objects
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
          scene.add(ambientLight);
          
          const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
          directionalLight.position.set(5, 5, 5);
          directionalLight.castShadow = true;
          scene.add(directionalLight);
          
          // Add subtle backlight
          const backLight = new THREE.DirectionalLight(0x9090ff, 0.5);
          backLight.position.set(-5, 5, -5);
          scene.add(backLight);
          
          // Start animation loop
          animate();
          
          // Handle window resize
          window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          });
          
          isThreeJsInitialized = true;
          console.log("Three.js initialized successfully");
          return true;
        } catch (error) {
          console.error("Error initializing Three.js:", error);
          document.getElementById('status').innerText = "Error creating 3D display";
          return false;
        }
      }
      
      // Animation loop
      function animate() {
        try {
          requestAnimationFrame(animate);
          
          if (nutritionPanel) {
            // Gentle floating animation
            nutritionPanel.position.y = 0.1 * Math.sin(Date.now() * 0.001);
          }
          
          renderer.render(scene, camera);
        } catch (error) {
          console.error("Error in animation loop:", error);
        }
      }
      
      // Create modern 3D nutrition panel
      function createNutritionPanel(nutritionData) {
        console.log("Creating nutrition panel with data:", nutritionData);
        
        if (!initThreeJs()) {
          console.error("Failed to initialize Three.js, cannot create nutrition panel");
          return;
        }
        
        // Remove any existing nutrition panel
        if (nutritionPanel) {
          scene.remove(nutritionPanel);
        }
        
        try {
          // Create a group to hold all panel elements
          nutritionPanel = new THREE.Group();
          
          // Create the main panel with rounded corners
          const roundedRectShape = new THREE.Shape();
          const width = 3.5;
          const height = 5.5;
          const radius = 0.2;
          
          roundedRectShape.moveTo(-width/2 + radius, -height/2);
          roundedRectShape.lineTo(width/2 - radius, -height/2);
          roundedRectShape.quadraticCurveTo(width/2, -height/2, width/2, -height/2 + radius);
          roundedRectShape.lineTo(width/2, height/2 - radius);
          roundedRectShape.quadraticCurveTo(width/2, height/2, width/2 - radius, height/2);
          roundedRectShape.lineTo(-width/2 + radius, height/2);
          roundedRectShape.quadraticCurveTo(-width/2, height/2, -width/2, height/2 - radius);
          roundedRectShape.lineTo(-width/2, -height/2 + radius);
          roundedRectShape.quadraticCurveTo(-width/2, -height/2, -width/2 + radius, -height/2);
          
          const extrudeSettings = {
            steps: 1,
            depth: 0.1,
            bevelEnabled: true,
            bevelThickness: 0.05,
            bevelSize: 0.05,
            bevelSegments: 3
          };
          
          const panelGeometry = new THREE.ExtrudeGeometry(roundedRectShape, extrudeSettings);
          const panelMaterial = new THREE.MeshPhongMaterial({
            color: 0xf9f9f9,
            transparent: true,
            opacity: 0.95,
            specular: 0x111111,
            shininess: 30
          });
          
          const panel = new THREE.Mesh(panelGeometry, panelMaterial);
          panel.rotation.x = Math.PI; // Flip to show front face
          nutritionPanel.add(panel);
          
          // Function to create modern text mesh
          function createTextMesh(text, size, color, y, isBold = false) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 1024;
            canvas.height = 256;
            
            // Fill with transparent background
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw text with better typography
            const fontWeight = isBold ? 'bold' : 'normal';
            context.font = `${fontWeight} 32px Arial, sans-serif`;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Add subtle text shadow for legibility
            if (isBold) {
              context.shadowColor = 'rgba(0,0,0,0.2)';
              context.shadowBlur = 4;
              context.shadowOffsetX = 1;
              context.shadowOffsetY = 1;
            }
            
            // Handle multiline text
            const lines = text.split('\\n');
            const lineHeight = 40;
            const startY = canvas.height/2 - (lines.length - 1) * lineHeight/2;
            
            lines.forEach((line, index) => {
              context.fillText(line, canvas.width/2, startY + index * lineHeight);
            });
            
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter; // Better text quality
            texture.magFilter = THREE.LinearFilter;
            
            // Create plane with texture
            const geometry = new THREE.PlaneGeometry(size, size * canvas.height / canvas.width);
            const material = new THREE.MeshBasicMaterial({
              map: texture,
              transparent: true,
              side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = y;
            mesh.position.z = -0.06; // Position in front
            
            return mesh;
          }
          
          // Parse nutrition data and create text
          const lines = nutritionData.split('\n');
          let startY = 2.3; // Starting position from top
          
          // Add title
          nutritionPanel.add(createTextMesh(lines[0], 3.2, '#1a73e8', startY, true));
          startY -= 0.7;
          
          // Add horizontal divider
          const dividerGeometry = new THREE.PlaneGeometry(3, 0.03);
          const dividerMaterial = new THREE.MeshBasicMaterial({ color: 0x1a73e8 });
          const divider = new THREE.Mesh(dividerGeometry, dividerMaterial);
          divider.position.y = startY + 0.2;
          divider.position.z = -0.05;
          nutritionPanel.add(divider);
          
          // Add data lines with better spacing and colors
          for (let i = 1; i < lines.length; i++) {
            const line = lines[i];
            
            // Format differently based on content
            if (line.startsWith('Name:') || line.startsWith('Brand:')) {
              // Product info in blue
              nutritionPanel.add(createTextMesh(line, 3, '#1a73e8', startY));
            } else if (line.includes('kcal')) {
              // Energy in orange
              nutritionPanel.add(createTextMesh(line, 3, '#f57c00', startY));
            } else {
              // Other nutritional info in dark gray
              nutritionPanel.add(createTextMesh(line, 3, '#202124', startY));
            }
            
            startY -= 0.55;
          }
          
          // Add rounded corners for a more modern look
          panel.geometry.computeVertexNormals();
          
          // Position the panel in front of the camera rather than to the side
          nutritionPanel.position.x = 0; 
          nutritionPanel.position.z = -3.5;
          nutritionPanel.rotation.y = 0; // Straight on
          
          // Add to scene with an entry animation
          nutritionPanel.scale.set(0.1, 0.1, 0.1);
          scene.add(nutritionPanel);
          console.log("Nutrition panel added to scene");
          
          // Panel entry animation
          const startTime = Date.now();
          const animatePanelEntry = function() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / 500, 1); // 500ms animation
            
            nutritionPanel.scale.set(
              0.1 + 0.9 * progress,
              0.1 + 0.9 * progress,
              0.1 + 0.9 * progress
            );
            
            if (progress < 1) {
              requestAnimationFrame(animatePanelEntry);
            }
          };
          
          animatePanelEntry();
        } catch (error) {
          console.error("Error creating nutrition panel:", error);
          document.getElementById('status').innerText = "Error displaying nutrition information";
        }
      }

      // Apply image enhancements to improve recognition
      function applyImageEnhancement(ctx, width, height) {
        // Get image data
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        // Simple contrast and brightness adjustment
        const contrast = 1.3; // Increase contrast
        const brightness = 15; // Slight brightness boost
        
        for (let i = 0; i < data.length; i += 4) {
          // Apply contrast and brightness
          data[i] = Math.min(255, Math.max(0, (data[i] - 128) * contrast + 128 + brightness)); // Red
          data[i+1] = Math.min(255, Math.max(0, (data[i+1] - 128) * contrast + 128 + brightness)); // Green
          data[i+2] = Math.min(255, Math.max(0, (data[i+2] - 128) * contrast + 128 + brightness)); // Blue
        }
        
        // Put the modified pixels back
        ctx.putImageData(imageData, 0, 0);
      }

      // Function to initialize the camera stream
      async function initCamera(switchCamera = false) {
        showLoadingIndicator(true);
        
        // Stop any existing streams
        if (currentStream) {
          currentStream.getTracks().forEach(track => track.stop());
        }
        
        // Toggle camera mode if switching
        if (switchCamera) {
          frontCamera = !frontCamera;
        }
        
        try {
          const facingMode = frontCamera ? 'user' : 'environment';
          document.getElementById('status').innerText = `Accessing ${frontCamera ? 'front' : 'back'} camera...`;
          
          const constraints = {
            video: { 
              facingMode: facingMode,
              width: { ideal: 1280 },
              height: { ideal: 720 }
            },
            audio: false
          };
          
          // For mobile Safari compatibility
          if (navigator.userAgent.includes('iPhone') || navigator.userAgent.includes('iPad')) {
            constraints.video = { 
              facingMode: facingMode,
              width: { min: 640, ideal: 1280, max: 1920 },
              height: { min: 480, ideal: 720, max: 1080 }
            };
          }
          
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          
          videoElement.srcObject = stream;
          currentStream = stream;
          
          // Update status with which camera is active
          document.getElementById('status').innerText = 'Using ' + 
            (frontCamera ? 'front' : 'back') + ' camera. Ready to scan.';
          
          // Set canvas size to match video
          videoElement.onloadedmetadata = () => {
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
          };
          
          // Initialize models in the background
          await loadModels();
          
          showLoadingIndicator(false);
          
          // Start in current mode
          if (currentMode === 'barcode') {
            startBarcodeScanning();
          } else {
            // Make sure video is visible in image mode
            videoElement.style.display = 'block';
            quaggaContainer.style.display = 'none';
            // Hide barcode UI
            barcodeScannerUI.style.display = 'none';
            // Start continuous recognition for image mode
            startContinuousRecognition();
          }
        } catch (err) {
          console.error('Error accessing camera:', err);
          showLoadingIndicator(false);
          showPermissionError(true);
        }
      }

      // Show/hide loading indicator
      function showLoadingIndicator(show) {
        loadingIndicator.style.display = show ? 'block' : 'none';
      }
      
      // Show/hide permission error
      function showPermissionError(show) {
        permissionError.style.display = show ? 'flex' : 'none';
      }

      // Load TensorFlow.js models with better configuration
      async function loadModels() {
        document.getElementById('status').innerText = 'Loading recognition models...';
        
        try {
          // Load MobileNet with higher confidence threshold
          mobilenetModel = await mobilenet.load({
            version: 2,
            alpha: 1.0 // Higher alpha for better accuracy
          });
          
          document.getElementById('status').innerText = 'Models loaded. Ready to scan.';
          return true;
        } catch (err) {
          console.error('Error loading models:', err);
          document.getElementById('status').innerText = 'Error loading recognition models.';
          return false;
        }
      }

      // Start continuous image recognition
      function startContinuousRecognition() {
        if (isRecognizing) return;
        isRecognizing = true;
        
        // Clear the recognition tracking map
        recognizedItems.clear();
        
        // Reset detection box
        hideDetectionBox();
        
        // Start the recognition loop
        recognizeLoop();
      }
      
      // Stop continuous recognition
      function stopContinuousRecognition() {
        isRecognizing = false;
      }
      
      // Show detection box around identified item
      function showDetectionBox(x, y, width, height) {
        const box = document.getElementById('detectionBox');
        
        // Store last detected position
        lastDetectedItemBox = { x, y, width, height };
        
        // Position the box
        box.style.left = `${x}px`;
        box.style.top = `${y}px`;
        box.style.width = `${width}px`;
        box.style.height = `${height}px`;
        
        // Show with animation
        box.style.display = 'block';
        box.style.opacity = '0';
        box.style.transform = 'scale(1.1)';
        
        // Apply animation
        setTimeout(() => {
          box.style.opacity = '1';
          box.style.transform = 'scale(1)';
        }, 10);
      }
      
      // Hide detection box
      function hideDetectionBox() {
        const box = document.getElementById('detectionBox');
        box.style.display = 'none';
        lastDetectedItemBox = null;
      }
      
      // Recognition loop for continuous processing
      async       function recognizeLoop() {
        if (!isRecognizing || currentMode !== 'image') return;
        
        const now = Date.now();
        if (now - lastRecognitionTime > recognitionInterval) {
          lastRecognitionTime = now;
          
          // Update status to show active scanning
          document.getElementById('status').innerText = 'Actively scanning... Point camera at food package';
          
          // Check if video is playing and models are loaded
          if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA && mobilenetModel) {
            // Capture current frame
            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
            
            try {
              // Apply image preprocessing to improve recognition
              applyImageEnhancement(ctx, canvas.width, canvas.height);
              
              // Perform classification
              const classifications = await mobilenetModel.classify(canvas, 5); // Get top 5 results
              
              console.log("Classifications:", classifications); // Debug
              
              // Filter for food-related items with reasonable confidence
              const foodItems = classifications.filter(item => {
                const className = item.className.toLowerCase();
                // Check each keyword against the class name
                return item.probability > 0.2 && // Lower threshold for better detection
                  foodKeywords.some(keyword => className.includes(keyword));
              });
              
              if (foodItems.length > 0) {
                const topResult = foodItems[0];
                const itemKey = topResult.className.split(',')[0].trim();
                
                // Track consistent recognitions
                if (!recognizedItems.has(itemKey)) {
                  recognizedItems.set(itemKey, { count: 1, confidence: topResult.probability });
                } else {
                  const item = recognizedItems.get(itemKey);
                  item.count++;
                  item.confidence = Math.max(item.confidence, topResult.probability);
                  recognizedItems.set(itemKey, item);
                  
                  // If we've seen this item consistently, search for it
                  if (item.count >= 2 && item.confidence > 0.4) {
                    document.getElementById('status').innerText = 
                      `Recognized: ${itemKey} (${Math.round(item.confidence * 100)}% confidence)`;
                    
                    // Show detection box (centered in viewport)
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    const boxWidth = Math.min(viewportWidth * 0.7, 300);
                    const boxHeight = Math.min(viewportHeight * 0.4, 200);
                    const boxX = (viewportWidth - boxWidth) / 2;
                    const boxY = (viewportHeight - boxHeight) / 2;
                    showDetectionBox(boxX, boxY, boxWidth, boxHeight);
                    
                    // Search for the item's nutrition data
                    searchFoodItem(itemKey);
                    
                    // Reset the tracking map after a successful recognition
                    recognizedItems.clear();
                    
                    // Pause recognition briefly after successful identification
                    await new Promise(resolve => setTimeout(resolve, 3000));
                  }
                }
              }
            } catch (err) {
              console.error('Error during continuous recognition:', err);
            }
          }
        }
        
        // Continue the loop
        requestAnimationFrame(recognizeLoop);
      }
      
      // Check if a class name is related to food or packaging
      function isFoodOrPackageRelated(className) {
        className = className.toLowerCase();
        return foodKeywords.some(keyword => className.includes(keyword));
      }

      // Start barcode scanning using QuaggaJS
      function startBarcodeScanning() {
        if (isQuaggaRunning) return;
        
        // Show scanner UI
        barcodeScannerUI.style.display = 'block';
        
        // Hide detection box if visible
        hideDetectionBox();
        
        // Clear the QuaggaJS container before reinitializing
        quaggaContainer.innerHTML = '';
        quaggaContainer.style.display = 'block';
        
        // Make sure video is hidden as Quagga will create its own
        videoElement.style.display = 'none';
        
        Quagga.init({
          inputStream: {
            name: "Live",
            type: "LiveStream",
            target: quaggaContainer,
            constraints: {
              facingMode: frontCamera ? "user" : "environment",
              width: { min: 640 },
              height: { min: 480 },
              aspectRatio: { min: 1, max: 2 }
            }
          },
          locator: {
            patchSize: "medium",
            halfSample: true
          },
          numOfWorkers: navigator.hardwareConcurrency ? Math.min(navigator.hardwareConcurrency, 4) : 2,
          frequency: 10, // Increased frequency for better detection
          decoder: {
            readers: ["ean_reader", "ean_8_reader", "upc_reader", "upc_e_reader"],
            debug: {
              drawBoundingBox: true,
              showPattern: true
            }
          },
          locate: true
        }, function(err) {
          if (err) {
            console.error(err);
            document.getElementById("status").innerText = "Error initializing barcode scanner.";
            return;
          }
          
          console.log("QuaggaJS initialized.");
          
          // Add willReadFrequently attribute to all canvases
          setTimeout(() => {
            const canvases = quaggaContainer.querySelectorAll('canvas');
            canvases.forEach(canvas => {
              const ctx = canvas.getContext('2d');
              if (ctx) ctx.willReadFrequently = true;
            });
            
            // Make sure video is visible
            const quaggaVideo = quaggaContainer.querySelector('video');
            if (quaggaVideo) {
              quaggaVideo.style.width = '100%';
              quaggaVideo.style.height = '100%';
              quaggaVideo.style.objectFit = 'cover';
            }
          }, 500);
          
          Quagga.start();
          isQuaggaRunning = true;
          document.getElementById("status").innerText = "Scanning for product barcode...";
        });
      }

      // Stop barcode scanning
      function stopBarcodeScanning() {
        if (isQuaggaRunning) {
          Quagga.stop();
          isQuaggaRunning = false;
          
          // Clear the container
          quaggaContainer.style.display = 'none';
          quaggaContainer.innerHTML = '';
          
          // Hide scanner UI
          barcodeScannerUI.style.display = 'none';
          
          // Show our video element again
          videoElement.style.display = 'block';
        }
      }

      // Search for food item using the Open Food Facts API with better error handling
      function searchFoodItem(itemName) {
        // Show loading indicator
        showLoadingIndicator(true);
        
        // Clean up the item name for search
        const searchTerm = itemName.split(',')[0].trim().toLowerCase();
        
        document.getElementById('status').innerText = `Searching for: ${searchTerm}...`;
        
        // Check cache first
        if (foodCache.has(searchTerm)) {
          const cachedData = foodCache.get(searchTerm);
          displayProductInfo(cachedData);
          showLoadingIndicator(false);
          return;
        }
        
        // Use the Open Food Facts search API
        fetch(`https://world.openfoodfacts.org/cgi/search.pl?search_terms=${encodeURIComponent(searchTerm)}&search_simple=1&action=process&json=1`)
          .then(response => {
            if (!response.ok) {
              throw new Error(`Network response was not ok: ${response.status}`);
            }
            return response.json();
          })
          .then(data => {
            if (data.products && data.products.length > 0) {
              const product = data.products[0]; // Use the first result
              
              // Cache the result
              foodCache.set(searchTerm, product);
              
              // Display product info
              displayProductInfo(product);
            } else {
              // No products found, try generic nutrition data
              document.getElementById('status').innerText = `No product found for: ${searchTerm}`;
              createGenericNutritionPanel(searchTerm);
            }
            showLoadingIndicator(false);
          })
          .catch(err => {
            console.error("Error searching product:", err);
            document.getElementById('status').innerText = "Error searching for product data.";
            createGenericNutritionPanel(searchTerm);
            showLoadingIndicator(false);
          });
      }
      
      // Display product information from API response
      function displayProductInfo(product) {
        try {
          console.log("Displaying product info:", product);
          
          // Format nutrition data
          const nutriments = product.nutriments || {};
                
          // Format nutrition data
          let labelText = "Nutrition Facts\n";
          labelText += `Name: ${product.product_name || "N/A"}\n`;
          labelText += `Brand: ${product.brands || "N/A"}\n`;
          
          // Format nutrition values with consistent units
          const energy = nutriments["energy-kcal"] ? 
            `${Math.round(nutriments["energy-kcal"])} kcal` : 
            (nutriments["energy"] ? `${Math.round(nutriments["energy"] / 4.184)} kcal` : "N/A");
          
          const fat = nutriments.fat ? 
            `${parseFloat(nutriments.fat).toFixed(1)}g` : "N/A";
          const sugars = nutriments.sugars ? 
            `${parseFloat(nutriments.sugars).toFixed(1)}g` : "N/A";
          const proteins = nutriments.proteins ? 
            `${parseFloat(nutriments.proteins).toFixed(1)}g` : "N/A";
          
          labelText += `Energy: ${energy}\n`;
          labelText += `Fat: ${fat}\n`;
          labelText += `Sugars: ${sugars}\n`;
          labelText += `Proteins: ${proteins}\n`;
          
          // Add salt or sodium if available
          if (nutriments.salt) {
            labelText += `Salt: ${parseFloat(nutriments.salt).toFixed(1)}g\n`;
          } else if (nutriments.sodium) {
            labelText += `Sodium: ${parseFloat(nutriments.sodium).toFixed(1)}g\n`;
          }
          
          document.getElementById('status').innerText = "Found: " + (product.product_name || "Unknown");
          
          // Create 3D nutrition panel
          createNutritionPanel(labelText);
        } catch (error) {
          console.error("Error displaying product info:", error);
          
          // Fallback to generic panel
          const productName = product && product.product_name ? product.product_name : "Unknown Product";
          createGenericNutritionPanel(productName);
        }
      }
      
      // Create generic nutrition panel when exact product isn't found
      function createGenericNutritionPanel(foodName) {
        // Generic nutrition data based on food type
        let labelText = "Estimated Nutrition\n";
        labelText += `Name: ${foodName}\n`;
        
        // Generic values based on food keywords
        let energy = "N/A";
        let fat = "N/A";
        let sugars = "N/A";
        let proteins = "N/A";
        
        // Very rough estimates for common food categories
        const foodLower = foodName.toLowerCase();
        
        if (foodLower.includes('chip') || foodLower.includes('crisp') || foodLower.includes('snack')) {
          energy = "150 kcal";
          fat = "10.0g";
          sugars = "1.5g";
          proteins = "2.0g";
        } else if (foodLower.includes('chocolate') || foodLower.includes('candy')) {
          energy = "200 kcal";
          fat = "12.0g";
          sugars = "20.0g";
          proteins = "2.5g";
        } else if (foodLower.includes('soda') || foodLower.includes('cola')) {
          energy = "120 kcal";
          fat = "0.0g";
          sugars = "30.0g";
          proteins = "0.0g";
        } else if (foodLower.includes('water') || foodLower.includes('bottle')) {
          energy = "0 kcal";
          fat = "0.0g";
          sugars = "0.0g";
          proteins = "0.0g";
        } else {
          energy = "100 kcal";
          fat = "5.0g";
          sugars = "3.0g";
          proteins = "3.0g";
        }
        
        labelText += `Energy: ${energy}\n`;
        labelText += `Fat: ${fat}\n`;
        labelText += `Sugars: ${sugars}\n`;
        labelText += `Proteins: ${proteins}\n`;
        labelText += `Note: Estimated values\n`;
        
        // Create 3D nutrition panel
        createNutritionPanel(labelText);
      }

      // Handle barcode detection
      Quagga.onDetected(function(result) {
        const code = result.codeResult.code;
        console.log("Barcode detected:", code);
        document.getElementById("status").innerText = "Barcode detected: " + code;
        
        // Show loading indicator
        showLoadingIndicator(true);
        
        // Temporarily stop scanning
        Quagga.pause();
        
        // Highlight detected barcode
        const scanArea = document.querySelector('.scan-area');
        if (scanArea) {
          scanArea.style.borderColor = 'rgba(76, 175, 80, 0.8)';
          scanArea.style.boxShadow = '0 0 20px rgba(76, 175, 80, 0.5)';
          setTimeout(() => {
            scanArea.style.borderColor = 'rgba(66, 133, 244, 0.8)';
            scanArea.style.boxShadow = '0 0 0 5000px rgba(0, 0, 0, 0.5)';
          }, 1000);
        }

        // Check cache first
        if (foodCache.has(code)) {
          const cachedData = foodCache.get(code);
          displayProductInfo(cachedData);
          showLoadingIndicator(false);
          setTimeout(() => Quagga.start(), 5000);
          return;
        }

        // Query the Open Food Facts API for product details
        fetch("https://world.openfoodfacts.org/api/v0/product/" + code + ".json")
          .then(response => {
            if (!response.ok) {
              throw new Error(`Network response was not ok: ${response.status}`);
            }
            return response.json();
          })
          .then(data => {
            if(data.status === 1) {
              const product = data.product;
              
              // Cache the result
              foodCache.set(code, product);
              
              // Display product info
              displayProductInfo(product);
            } else {
              document.getElementById("status").innerText = "Product not found for barcode: " + code;
            }
            
            showLoadingIndicator(false);
            
            // Resume scanning after a short delay
            setTimeout(() => Quagga.start(), 5000);
          })
          .catch(err => {
            console.error("Error fetching product data:", err);
            document.getElementById("status").innerText = "Error fetching nutrition data.";
            showLoadingIndicator(false);
            setTimeout(() => Quagga.start(), 3000);
          });
      });

      // Set up event listeners
      document.getElementById('barcodeMode').addEventListener('click', function() {
        if (currentMode === 'barcode') return;
        
        currentMode = 'barcode';
        this.classList.add('active');
        document.getElementById('imageMode').classList.remove('active');
        
        // Stop continuous recognition if running
        stopContinuousRecognition();
        
        // Start barcode scanning
        startBarcodeScanning();
      });

      document.getElementById('imageMode').addEventListener('click', function() {
        if (currentMode === 'image') return;
        
        currentMode = 'image';
        this.classList.add('active');
        document.getElementById('barcodeMode').classList.remove('active');
        
        // Stop barcode scanning
        stopBarcodeScanning();
        
        // Start continuous recognition
        startContinuousRecognition();
      });
      
      document.getElementById('switchCameraBtn').addEventListener('click', function() {
        // Stop current scanning if active
        if (isQuaggaRunning) {
          stopBarcodeScanning();
        }
        
        // Stop continuous recognition if running
        if (isRecognizing) {
          stopContinuousRecognition();
        }
        
        // Initialize with camera switch
        initCamera(true);
      });
      
      document.getElementById('retryPermission').addEventListener('click', function() {
        showPermissionError(false);
        initCamera();
      });

      // Initialize the app
      window.addEventListener('load', () => {
        // Initialize camera
        initCamera();
        
        // Initialize Three.js
        initThreeJs();
      });
      
      // Handle visibility changes (app going to background)
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
          // App came back to foreground
          if (currentMode === 'barcode' && !isQuaggaRunning) {
            startBarcodeScanning();
          } else if (currentMode === 'image' && !isRecognizing) {
            startContinuousRecognition();
          }
        } else {
          // App went to background
          if (isQuaggaRunning) {
            Quagga.stop();
            isQuaggaRunning = false;
          }
          if (isRecognizing) {
            stopContinuousRecognition();
          }
        }
      });
      
      // Cleanup function for when the page is unloaded
      window.addEventListener('beforeunload', () => {
        if (currentStream) {
          currentStream.getTracks().forEach(track => track.stop());
        }
        if (isQuaggaRunning) {
          Quagga.stop();
        }
      });
    </script>
  </body>
</html>